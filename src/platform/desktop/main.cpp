#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include "wobs/Grid.hpp"
#include "wobs/Bot.hpp"
#include "wobs/Ball.hpp"
#include <sstream>
// src/platform/desktop/main.cpp
#include <iostream>
Ball* game_ball = nullptr;
const int WIN_W=1200,WIN_H=700,CELL=12,GLX=0,GRX=99,GYS=20,GYE=29; int sl=0,sr=0; const int WS=3; Ball* gb=nullptr; TTF_Font* f=nullptr; SDL_Color w={255,255,255,255};
struct UI { std::vector<int> p={0,4}; int di=-1; void r(SDL_Renderer* r,int x,int y){ for(int i=0;i<p.size();++i){ SDL_Color c=p[i]==0?SDL_Color{255,255,0,255}:(p[i]==3?SDL_Color{200,0,0,255}:SDL_Color{0,0,200,255}); SDL_SetRenderDrawColor(r,c.r,c.g,c.b,255); SDL_RenderFillRect(r,new SDL_Rect{x,y+i*40,30,30}); std::ostringstream o;o<<p[i]; auto* s=TTF_RenderText_Solid(f,o.str().c_str(),w); auto* t=SDL_CreateTextureFromSurface(r,s); SDL_Rect d={x+35,y+i*40+5,s->w,s->h}; SDL_RenderCopy(r,t,nullptr,&d); SDL_FreeSurface(s); SDL_DestroyTexture(t); } } bool h(SDL_Event& e,int x,int y){ if(e.type==SDL_MOUSEBUTTONDOWN&&e.button.button==SDL_BUTTON_LEFT){ for(int i=0;i<p.size();++i)if(e.button.x>=x&&e.button.x<x+100&&e.button.y>=y+i*40&&e.button.y<y+i*40+35){ di=i; return true; } } if(e.type==SDL_MOUSEBUTTONUP&&di!=-1){ int ny=(e.button.y-y)/40; if(ny>=0&&ny<p.size()&&ny!=di)std::swap(p[di],p[ny]); di=-1; return true; } return false; } };
void rt(SDL_Renderer* r,const std::string& t,int x,int y){ auto* s=TTF_RenderText_Solid(f,t.c_str(),w); auto* tex=SDL_CreateTextureFromSurface(r,s); SDL_Rect d={x,y,s->w,s->h}; SDL_RenderCopy(r,tex,nullptr,&d); SDL_FreeSurface(s); SDL_DestroyTexture(tex); }
void rr(Grid& g,Ball& b){ b=Ball(Position(50,25)); gb=&b; g.setBallPos(b.pos); }
int main(){ SDL_Init(SDL_INIT_VIDEO); TTF_Init(); auto* win=SDL_CreateWindow("WoBS",0,0,WIN_W,WIN_H,0); auto* ren=SDL_CreateRenderer(win,-1,SDL_RENDERER_ACCELERATED); f=TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",28); Grid g(100,50); Ball b(Position(50,25)); gb=&b; g.setBallPos(b.pos); for(int y=GYS;y<=GYE;++y){ g.set(Position(GLX,y),3); g.set(Position(GRX,y),4); } Bot b1(1,Position(20,25)), b2(2,Position(80,25)); UI ui; bool q=false; Uint64 l=SDL_GetPerformanceCounter(); while(!q){ SDL_Event e; while(SDL_PollEvent(&e)){ if(e.type==SDL_QUIT)q=true; ui.h(e,20,20); } b1.setPriority(ui.p); float dt=(SDL_GetPerformanceCounter()-l)/(float)SDL_GetPerformanceFrequency(); l=SDL_GetPerformanceCounter(); if(dt>0.1f)dt=0.1f; b.tick(g,dt); g.setBallPos(b.pos); b1.tick(g,dt,true); b2.tick(g,dt,false); if(b.pos.x==GLX&&b.pos.y>=GYS&&b.pos.y<=GYE){ sr++; rr(g,b); } if(b.pos.x==GRX&&b.pos.y>=GYS&&b.pos.y<=GYE){ sl++; rr(g,b); } SDL_SetRenderDrawColor(ren,30,30,30,255); SDL_RenderClear(ren); SDL_SetRenderDrawColor(ren,200,0,0,255); for(int y=GYS;y<=GYE;++y)SDL_RenderFillRect(ren,new SDL_Rect{GLX*CELL,y*CELL,CELL,CELL}); SDL_SetRenderDrawColor(ren,0,0,200,255); for(int y=GYS;y<=GYE;++y)SDL_RenderFillRect(ren,new SDL_Rect{GRX*CELL,y*CELL,CELL,CELL}); SDL_SetRenderDrawColor(ren,255,255,0,255); SDL_Rect br={b.pos.x*CELL,b.pos.y*CELL,CELL,CELL}; SDL_RenderFillRect(ren,&br); auto db=[&](const Bot& bot,SDL_Color c){ SDL_SetRenderDrawColor(ren,c.r,c.g,c.b,255); Position p=bot.position(); int cx=p.x*CELL+CELL/2,cy=p.y*CELL+CELL/2; for(int i=0;i<8;++i){ float a=bot.phys.rot+i*0.785398f; int ex=cx+std::cos(a)*CELL*0.6f, ey=cy+std::sin(a)*CELL*0.6f; SDL_RenderDrawLine(ren,cx,cy,ex,ey); } SDL_Rect r={p.x*CELL,p.y*CELL,CELL,CELL}; SDL_RenderFillRect(ren,&r); }; db(b1,{0,200,255,255}); db(b2,{255,100,100,255}); ui.r(ren,20,20); std::ostringstream o;o<<sl<<" : "<<sr; rt(ren,o.str(),WIN_W/2-50,10); if(sl>=WS||sr>=WS){ rt(ren,sl>=WS?"YOU WIN!":"AI WINS!",WIN_W/2-120,WIN_H/2-50); SDL_RenderPresent(ren); SDL_Delay(3000); q=true; } SDL_RenderPresent(ren); SDL_Delay(16); } TTF_Quit(); SDL_Quit(); return 0; }
